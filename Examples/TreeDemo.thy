theory TreeDemo
imports "../IsaHipster"

begin


datatype 'a Lst = 
  Emp
  | Cons "'a" "'a Lst"

fun app :: "'a Lst \<Rightarrow> 'a Lst \<Rightarrow> 'a Lst" 
where 
  "app Emp xs = xs"
| "app (Cons x xs) ys = Cons x (app xs ys)"

fun rev :: "'a Lst \<Rightarrow> 'a Lst"
where 
  "rev Emp = Emp"
| "rev (Cons x xs) = app (rev xs) (Cons x Emp)"

fun hd :: "'a Lst \<Rightarrow> 'a" 
where
  "hd(Cons x xs) = x"

ML{* Hipster_Explore.explore  @{context} ["TreeDemo.app", "TreeDemo.rev", "TreeDemo.hd"]*}
lemma lemma_a [thy_expl]: "app x2 Emp = x2"
by (tactic {* Hipster_Tacs.induct_simp_metis @{context} @{thms TreeDemo.app.simps TreeDemo.rev.simps TreeDemo.hd.simps thy_expl} *})

lemma lemma_aa [thy_expl]: "app (app x2 y2) z2 = app x2 (app y2 z2)"
by (tactic {* Hipster_Tacs.induct_simp_metis @{context} @{thms TreeDemo.app.simps TreeDemo.rev.simps TreeDemo.hd.simps thy_expl} *})

lemma lemma_ab [thy_expl]: "TreeDemo.hd (app x2 x2) = TreeDemo.hd x2"
by (tactic {* Hipster_Tacs.induct_simp_metis @{context} @{thms TreeDemo.app.simps TreeDemo.rev.simps TreeDemo.hd.simps thy_expl} *})

lemma lemma_ac [thy_expl]: "app (TreeDemo.rev x5) (TreeDemo.rev y5) = TreeDemo.rev (app y5 x5)"
by (tactic {* Hipster_Tacs.induct_simp_metis @{context} @{thms TreeDemo.app.simps TreeDemo.rev.simps TreeDemo.hd.simps thy_expl} *})

lemma lemma_ad [thy_expl]: "TreeDemo.rev (TreeDemo.rev x5) = x5"
by (tactic {* Hipster_Tacs.induct_simp_metis @{context} @{thms TreeDemo.app.simps TreeDemo.rev.simps TreeDemo.hd.simps thy_expl} *})



datatype 'a Tree = 
  Leaf 'a 
  | Node "'a Tree""'a Tree"

fun mirror :: "'a Tree => 'a Tree"
where
  "mirror (Leaf x) = Leaf x"
| "mirror (Node l r) = Node (mirror r) (mirror l)"

fun tmap :: "('a => 'b) => 'a Tree => 'b Tree"
where
  "tmap f (Leaf x) = Leaf (f x)"
| "tmap f (Node l r) = Node (tmap f l) (tmap f r)" 

ML{* Hipster_Explore.explore  @{context} ["TreeDemo.tmap", "TreeDemo.mirror"]; *}
lemma lemma_ae [thy_expl]: "mirror (tmap x2 y2) = tmap x2 (mirror y2)"
by (tactic {* Hipster_Tacs.induct_simp_metis @{context} @{thms TreeDemo.tmap.simps TreeDemo.mirror.simps thy_expl} *})

lemma lemma_af [thy_expl]: "mirror (mirror x2) = x2"
by (tactic {* Hipster_Tacs.induct_simp_metis @{context} @{thms TreeDemo.tmap.simps TreeDemo.mirror.simps thy_expl} *})


fun flat_tree :: "'a Tree => 'a Lst"
where
  "flat_tree (Leaf x) = Cons x Emp"
| "flat_tree (Node l r) =  app (flat_tree l) (flat_tree r)"

ML{* Hipster_Explore.explore  @{context} ["TreeDemo.app","TreeDemo.rev", "TreeDemo.mirror",
                                          "TreeDemo.flat_tree"]; *}
lemma lemma_ag [thy_expl]: "TreeDemo.rev (flat_tree x5) = flat_tree (mirror x5)"
by (tactic {* Hipster_Tacs.induct_simp_metis @{context} @{thms TreeDemo.app.simps TreeDemo.rev.simps TreeDemo.mirror.simps TreeDemo.flat_tree.simps thy_expl} *})

fun rigthmost :: "'a Tree \<Rightarrow> 'a"
where 
  "rigthmost (Leaf x) = x"
|  "rigthmost (Node l r) = rigthmost r"

fun leftmost :: "'a Tree \<Rightarrow> 'a"
where 
  "leftmost (Leaf x) = x"
|  "leftmost (Node l r) = leftmost l"

ML{* Hipster_Explore.explore  @{context} ["TreeDemo.hd","TreeDemo.rev", "TreeDemo.mirror","TreeDemo.flat_tree", "TreeDemo.rigthmost", "TreeDemo.leftmost"]; *}
lemma lemma_ah [thy_expl]: "leftmost (mirror x2) = rigthmost x2"
by (tactic {* Hipster_Tacs.induct_simp_metis @{context} @{thms TreeDemo.hd.simps TreeDemo.rev.simps TreeDemo.mirror.simps TreeDemo.flat_tree.simps TreeDemo.rigthmost.simps TreeDemo.leftmost.simps thy_expl} *})

lemma hd_app[simp] : "xs \<noteq> Emp \<Longrightarrow> hd(app xs ys) = hd xs "
by (induct xs, simp_all)

lemma non_empty_app[simp] : "\<lbrakk>xs \<noteq> Emp \<or> ys \<noteq> Emp\<rbrakk> \<Longrightarrow> (app xs ys) \<noteq> Emp"
by (induct xs, simp_all)

lemma flat_tree_non_emp[simp] : "flat_tree t \<noteq> Emp"
by(induct t, simp_all)

(* This lemma is discoved by Hipster, but cannot be proved. It is returned with an oops. 
   This is because it needs the above three non-equational lemmas, which cannot be
   generated by QuickSpec. However, we get a hint to the first one from the previosuly
   discovered lemma_ab, which look a bit too specific, hinting at a missing side-condition.
   The other two fall out of the blocked subgoal in the initial proof attempt of the below lemma.
*)
lemma unproved_from_hipster : "TreeDemo.hd (flat_tree x) = leftmost x"
by(induct x, simp_all)




end
