\label{sec:evaluation}

In this section we present an evaluation of Hispter's automated tactics, an analysis which had not been performed for Hipster to the same extent priorly.

Keeping in mind evaluation of automated tools for interactive theorem proving necessarily has to consider some degree of interaction, two forms of evaluation have been carried out:

\begin{itemize}
\item case studies on algebraic data types and operations on them; in particular focusing on inductive theories for natural numbers and lists

\item evaluation on problems from  TIP (Tons of Inductive Problems) \cite{tip-benchmarks}, a set of benchmarks and challenge problems for inductive theorem provers.
\end{itemize}

From TIP, we evaluate Hipster over two sets of problems employed in previous works on inductive theorem proving: Johansson, Dixon and Bundy's work on case-analysis for rippling \cite{IsaPcase} (we denote it \emph{case-analysis}), and prior work by Ireland and Bundy on employing proof failure to guide lemma discovery and patch inductive proofs \cite{productiveuse} (we denote it \emph{prod-failure}).

\subsection{Method}

To evaluate performance on TIP, each problem is analysed individually, in isolation from others, to assess how far Hipster can go from bare definitions.
%
Theory explorations were only run for those whenever the problem was not provable by the recursion induction tactic directly, i.e. when the problem was missing helping lemmas.
%
Explorations were first performed on the individual functions appearing in the problem definition, jointly with their auxiliary functions. These were followed by explorations on groups of said functions if required, leaving conditional exploration as the last exploration to be run before defining the problem as non-provable by Hipster.

As already specified, conditional lemma discovery is limited to explore a single predicate at a time to define side-conditions. For the present evaluation this has sufficed.

Additionally, to test Hipster's capacity when working on strictly newly defined theories, no assumptions nor properties from theories in Isabelle/HOL were considered during proof search.
%
As an example, natural numbers are not Isabelle/HOL's, but redefined.
%
Hence, predefined notions of orderings and other properties do not play a part in proofs obscuring the results of Hipster's actual work.
%
In this way, we only consider as the base starting point a set of definitional statements, aligning with the purpose of proving based on structure and construction of programs.

\subsection{Results}

The following table summarises statistics on the two sets of the benchmarks run.
%
Columns \emph{EQ} and \emph{COND} do so for problems defined by an equational and a conditional theorem respectively.

\begin{tabularx}{\textwidth}{l | X X | X X}
  & \multicolumn{2}{c|}{Case-analysis} & \multicolumn{2}{c}{Prod-failure} \\
  &  EQ & COND & EQ & COND \\
  \hline
  Total number of benchmarks & 71 & 15 & 38 & 12 \\
  \hline
  Fully automated & 67 & 14 & 29 & 12 \\
  Partially automated & 4 & 0 & 6 & 0 \\
  \hline
  Prior exploration & 33 & 4 & 34 & 4 \\
  Conditional exploration & 6 & 2 & 2 & 3 \\
  \hline
  Recursion induction & 29 & 6 & 1 & 1 \\
  Recursion induction on sub-lemmas & 16 & 1 & 5 & 0 \\
  \hline
  Filter theorems for FO prover & 3 & 0 & 0 & 0 \\ % XXX: remove this since we don't mention these options?
\end{tabularx}

\paragraph{Automation}
%
Overall, the rate of fully automated provability on the benchmark set is 90\%, considering fully automation the solving of a problem only with discovered lemmas and Hipster's automated recursion induction.
%
For conditional lemmas in the test set this rate is higher, 96\%.

A number of theorems (problems $52$, $53$, $72$, $74$ from \emph{case-analysis}; and $2$, $4$, $5$, $20$, $22$, $23$ from \emph{prod-failure}) required one of the following two similar lemmas, not automatically proven in a first instance (neither by structural nor recursion induction):

\begin{lstlisting}[ mathescape, columns=fullflexible,keepspaces, basicstyle=\fontfamily{lmvtt}\selectfont, ]
len (x @ y) = len (y @ x)
count z (x @ y) = count z (y @ x)
\end{lstlisting}

\noindent The failure is associated to less general auxiliary lemmas not being discovered. % Discovery possibly because discovery of lemmas limits constructed terms to a certain depth.

These examples seem to indicate that recursion induction may not suffice when a non-commutative operation nested within another has commuting arguments at each side of an equality.
%
At least not in the absence of smaller related lemmas corresponding to subgoals.
%
This seems reasonable: the structure of the terms at each side of the equality will differ upon induction.

Nonetheless, proofs for the problems associated to these lemmas can be partially automated.
%
When extracted, the open subgoals are provable by Hipster.
%
Alternatively, for both cases, one can observe that the outermost function applied, \isaCode{len} and \isaCode{count} respectively, acts as a relator function between two datatypes.
%
Furthermore, these will in fact act as relator functions between list concatenation \isaCode{@} and addition for natural numbers \isaCode{plus}.
%
Since \isaCode{plus} does not occur in the problems to be proven, it is not added to the exploration directly.
%
Adding adding \isaCode{plus} interactively, Hipster discovers and proves automatically the lemmas:

\begin{lstlisting}[ mathescape, columns=fullflexible,keepspaces, basicstyle=\fontfamily{lmvtt}\selectfont, ]
len (x @ y) = plus (len x) (len y)
count z (x @ y) = plus (count z x) (count z y)
\end{lstlisting}

\noindent Along with the commutative law for \isaCode{plus}, also discovered and proven automatically, these enable the automation of the two pending proofs without further intervention.
%
And so, the corresponding TIP problems are solved as well.

% TODO: successive inductions!

\paragraph{Theory exploration}

Just over half of the problems required prior lemma discovery, indicating the benefit of theory exploration.
%
Not surprisingly, equational lemmas were much more likely than conditionals to need exploration.
%
Equations are unrestricted and more general, hence potentially requiring more steps to asses their different case branches.
%
On the other hand, for these benchmarks, conditionals provided constraints that narrow down cases.

A smaller subset of problems were provable with the aid of conditional exploration, namely those involving functions defined in terms of some predicate.

\paragraph{Recursion induction}

Whereas recursion induction was not necessary as often as theory exploration (whether for the main theorem or auxiliary lemmas), its impact is still notable.
%
Structural induction was always attempted before by the tactic, meaning theorems solved via recursion induction (around a third of the benchmarks) would have not been solved otherwise, at least not with the degree of exploration carried out.
 
The results suggest recursion induction can save on exploration time.
%
It provides appropriate induction patterns that avoid the need for sub-lemmas about specific constructor combinations.


\subsection{Comparison}

% Briefly describe others tested against

\begin{tabularx}{\textwidth}{l | X X X | X X | X | X | X | X X X}
  & \multicolumn{3}{|c|}{Hipster}
  	& \multicolumn{2}{c|}{HipSpec}
  	& \multicolumn{1}{c|}{Zeno}
  	& \multicolumn{1}{c|}{IsaPlanner}
  	& \multicolumn{1}{c|}{CVC4}
  	& \multicolumn{3}{c}{Pirate} \\
  \hline
  Case-analysis & 80 & (84) & [85] & 80 & & 82 & 47 & 80 & 85 & & [86] \\
  Prod-failure & 41 & (47) & & 44 & (47) & 21 & - & 40 & & (47) & \\
\end{tabularx}

% Specify meaning of the numbers

% Draw conclusions and compare the different approaches; mainly with HipSpec and Pirate (as an example from which we can draw a difference with using generalisation)

% Emphasise interaction aspect


% \subsection{Discussion}   % Observed behaviour
