\label{sec:rec-ind}

A recursion induction scheme is specific for and associated to a function's definition.
%
Its use entails a stronger induction scheme which corresponds closer to a given definition and hence the cases considered in its simplification rules.
%
We further explain recursion induction in this section and the benefit in considering these schemata.

\subsection{Recursion induction}

When defining a recursive function over an inductive datatype one might traverse arguments following a different pattern to the strictly structural one (the one arising from a datatype's definition).
%
This pattern could be more specific, or even less so, than following the datatype.

For instance, take the functions on lists \isaCode{sorted} and \isaCode{last}:

\begin{lstlisting}[ mathescape, columns=fullflexible,keepspaces, basicstyle=\fontfamily{lmvtt}\selectfont, ]
fun sorted :: "Nat List $\Rightarrow$ Bool" where
  "sorted [] = True"
| "sorted ([_]) = True"
| "sorted (r # (t # ts)) = (r $\le$ t & sorted (t # ts))"

fun last :: "'a List $\Rightarrow$ 'a" where
  "last ([t]) = t"
| "last (_ # ts) = last ts"
\end{lstlisting}

\noindent From these definitions' structures one can derive two new induction principles.
%
Structural induction on lists considers the base-case \isaCode{[]} (the empty list) and step-case \isaCode{t \# ts} (a list with an element inserted at the front).
%
In the case of \isaCode{sorted}, cases are broken down into more detailed ones by including an additional base-case \isaCode{[t]} (the singleton list) and restricting the step-case to lists with at least two elements \isaCode{r \# t \# ts}.
%
Meanwhile \isaCode{last} is not defined for the case \isaCode{[]} and hence partially defined, meaning the induction scheme it gives rise to is to be completed with such a case, as the corresponding induction scheme depicts:

% TODO: update
\vspace{2 mm}

\inferrule [SortedInd]
  {P\;([]) \\ \forall u\;\; P\;(u \;\#\; []) \\ \forall r, \; t, \; ts\;\; (P\;(r \;\#\; ts) \; \Longrightarrow\;P\;(t\;\#\; (r\;\#\; ts)))}
  {\forall x \;\; P\;(x)}

\inferrule [LastInd]
  {\forall u\;\; P\;(u \;\#\; []) \\ \forall r, \; t, \; ts\;\; (P\;(r\;\#\; ts) \; \Longrightarrow\;P\;(t \;\#\; (r\;\#\; ts))) \\ P\;([])}
  {\forall x \;\; P\;(x)}

\vspace{2 mm}


Induction determined by these schemata is called \emph{recursion induction} or \emph{computation induction}.
%
They can isolate sub-units not represented in a datatype's structure as being atomic, such as lists with at least two elements in the scheme for \isaCode{sorted}.
%
Recursion induction hence provides an immediate and more specific structure for reasoning about other recursion patterns where a simple structural induction would fail to set appropriate base cases for the inductive step to succeed.

Particularly, within Isabelle/HOL these schemata are automatically derived as theorems from recursive functions' termination order \cite{krauss-term}.

\subsubsection*{Recursion induction in a proof}

%% Example from presentation on difference

Let us take for instance the already introduced conditional lemma required in proving insertion sort's correctness \isaCode{sorted xs $\Longrightarrow$ sorted (insert x xs)}.


Applying structural induction would produce the subgoals:

\begin{lstlisting}[ mathescape, columns=fullflexible,keepspaces, basicstyle=\fontfamily{lmvtt}\selectfont, ]
1. sorted [] $\Longrightarrow$ sorted (insert x [])
2. $\wedge$ a y. (sorted y $\Longrightarrow$ sorted (insert x y)) $\Longrightarrow$ sorted (a # y) $\Longrightarrow$ sorted (insert x (a # y))
\end{lstlisting}

\noindent Whilst \isaCode{sorted}'s recursion induction would yield:

\begin{lstlisting}[ mathescape, columns=fullflexible,keepspaces, basicstyle=\fontfamily{lmvtt}\selectfont, ]
1. sorted [] $\Longrightarrow$ sorted (insert x [])
2. $\wedge$ u. sorted [u] $\Longrightarrow$ sorted (insert x [u])
3. $\wedge$ r t ts. (sorted (t # ts) $\Longrightarrow$ sorted (insert x (t # ts))) $\Longrightarrow$ sorted (r # t # ts) $\Longrightarrow$
                sorted (insert x (r # t # ts))
\end{lstlisting}

The latter set of subgoals leads to an immediate proof of the main lemma thanks to its definition of steps being parallel to that of the actual predicate.
%
In contrast, the former, even though intuitively looks immediate to prove, is not sufficiently generalised to be so nor does it specify any intermediate result on inserting an element on a concrete non-empty list (in our case, the singleton list) which would enable to prove the subgoal for any arbitrary list.


\subsection{A tactic (not only) for conditionals}

\subsubsection*{Simultaneous induction}

The final tactic for Hipster explores the proofs one could attain by recursion inductions derived from either elements in a side-condition or in the conclusion of the lemma to be proven.
%
As a side-result, this increases the scope of Hipster's original approach for equational lemmas too.

A notable gain, affecting both conditional and equational lemmas, is that of having the capability of performing simultaneous induction.
%
Such is the case for the list function \isaCode{zip}'s recursion induction scheme, which corresponds to parallel induction on lists:

\inferrule [ZipInd]
  {\forall ts\;\; P\;([],\; ts) \\ \forall z,\; rs\;\; P\;(z\;\#\; rs, [])  \\ \forall z,\; y,\; rs,\; ts\;\; (P\;(rs,\;ts) \Longrightarrow\; P\;(z\; \# \; rs,\; y\;\#\; ts))}
  {\forall xs, \; ys \;\; P\;(xs,\; ys)}

\noindent This scheme, along with some initial theory exploration, allows theorems like the following to be provable:

\begin{lstlisting}[   mathescape,   columns=fullflexible,   basicstyle=\fontfamily{lmvtt}\selectfont, ]
zip (xs @ ys) zs = (zip xs (take (len xs) zs)) @ (zip ys (drop (len xs) zs))
\end{lstlisting}

\noindent Or even the alternative similar conditional lemma to be immediately provable:

\begin{lstlisting}[   mathescape,   columns=fullflexible,   basicstyle=\fontfamily{lmvtt}\selectfont, ]
len a = len b $\Longrightarrow$ (zip a b) @ (zip c d) = zip (a @ c) (b @ d)
\end{lstlisting}


\subsubsection*{Flexibilising Hipster}

% Include or not?

% Very brief overview of other aspects more interaction-oriented that improve Hipster



