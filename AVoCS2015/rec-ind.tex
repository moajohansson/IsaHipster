\label{sec:rec-ind}

\subsection{Recursion induction}

When defining a recursive function over an inductive datatype one might traverse arguments following a different pattern to the strictly structural one.
%
This pattern could be more specific, or even less so, than the structural one.

For instance, take the functions on lists \isaCode{sorted} and \isaCode{last}:

\begin{lstlisting}[ mathescape, columns=fullflexible,keepspaces, basicstyle=\fontfamily{lmvtt}\selectfont, ]
fun sorted :: "Nat List $\Rightarrow$ Bool" where
  "sorted [] = True"
| "sorted (_ # []) = True"
| "sorted (r # (t # ts)) = (r $\le$ t & sorted (t # ts))"

fun last :: "'a List $\Rightarrow$ 'a" where
  "last (t # []) = t"
| "last (_ # ts) = last ts"
\end{lstlisting}

\noindent From these definitions' structures one can derive two new induction principles.
%
In the case of \isaCode{sorted}, cases are broken down into more detailed ones whilst \isaCode{last} is partially defined, meaning the induction scheme it gives rise to is to be completed with its missing case for empty lists, as the corresponding induction scheme depicts:

\inferrule [SortedInd]
  {P\;([]) \\ \forall u\;\; P\;(u \;\#\; []) \\ \forall t, \; r, \; ts\;\; ((t\;\#\; r \; \Longrightarrow\; P\;(r \;\#\; ts)) \; \Longrightarrow\;P\;(t\;\#\; (r\;\#\; ts)))}
  {\forall x \;\; P\;(x)}

\inferrule [LastInd]
  {P\;(u \;\#\; []) \\ \forall r, \; t, \; ts\;\; (P\;(r\;\#\; ts) \; \Longrightarrow\;P\;(t \;\#\; (r\;\#\; ts))) \\ P\;([])}
  {\forall x \;\; P\;(x)}

Induction determined by these schemata is called \emph{recursion induction} or \emph{computation induction}.
%
They can isolate sub-units not represented in a datatypes structure as being atomic, such as lists with at least two elements in the scheme for \isaCode{sorted}.
%
Recursion induction hence provides an immediate and more specific structure for reasoning about other recursion patterns where a simple structural induction would fail to set appropriate base cases for the inductive step to succeed.

Particularly, within Isabelle/HOL these schemata are automatically derived as theorems from recursive functions termination order \cite{krauss-term}.
 
 
\subsection{Recursion induction for conditionals}


\subsection{A tactic (not only) for conditionals}

\subsubsection*{Simultaneous induction}

The final tactic for Hipster explores the proofs one could attain by recursion inductions derived from either elements in a side-condition or in the conclusion of the lemma to be proven.
%
As a side-result, this increases the scope of Hipster's original approach for equational lemmas too.

A notable gain, affecting both conditional and equational lemmas, is that of having the capability of performing simultaneous induction.
%
Such is the case for the list function \isaCode{zip}'s recursion induction scheme, which corresponds to parallel induction on lists:

\inferrule [ZipInd]
  {\forall ts\;\; P\;([],\; ts) \\ \forall z,\; rs\;\; P\;(z\;\#\; rs, [])  \\ \forall z,\; y,\; rs,\; ts\;\; (P\;(rs,\;ts) \Longrightarrow\; P\;(z\; \# \; rs,\; y\;\#\; ts))}
  {\forall xs, \; ys \;\; P\;(xs,\; ys)}

\noindent This scheme, along with some initial theory exploration, allows theorems like the following to be provable:

\begin{lstlisting}[   mathescape,   columns=fullflexible,   basicstyle=\fontfamily{lmvtt}\selectfont, ]
zip (xs @ ys) zs = (zip xs (take (len xs) zs)) @ (zip ys (drop (len xs) zs))
\end{lstlisting}

\noindent Or even the alternative similar conditional lemma to be immediately provable:

\begin{lstlisting}[   mathescape,   columns=fullflexible,   basicstyle=\fontfamily{lmvtt}\selectfont, ]
len a = len b $\Longrightarrow$ (zip a b) @ (zip c d) = zip (a @ c) (b @ d)
\end{lstlisting}


\subsubsection*{Flexibilising Hipster}

% Include or not?

% Very brief overview of other aspects more interaction-oriented that improve Hipster



