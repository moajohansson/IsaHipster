\label{sec:intro}

Theory exploration is a technique for automatically discovering new interesting lemmas in a formal mathematical theory development. These lemmas are intended to help constructing a richer background theory about the concepts at hand (e.g. functions and datatypes) which can be useful both to enhance the power of automation as well as being of use in interactive proofs. 

Something about other theory exploration systems here, and mention of Hipster and what it is.

Lemma discovery by theory exploration has previously been restricted to equational properties only. In this paper we take the first steps towards lifting this restriction and exploring also conditional conjectures. Conditional lemmas are necessary if we for example want to prove properties about sorting algorithms.

Example here: insertion sort.

Conditionals introduce a big challenge for theory exploration. First of all, the search space greatly increases: what statements should be picked as potentially interesting side-conditions to explore? Secondly, as our theory exploration system relies on generation of random test-cases, we also need to ensure that we perform enough tests where the condition evaluates to true, otherwise the whole conjecture is trivially true. As Hipster is designed as an interactive system, we avoid the first problem by asking the user to specify under which condition theory exploration should occur. In the example above, this would require the user to tell Hipster that the predicate \texttt{sorted} is an interesting pre-condition, in addition to which function symbols should be explored in the bodies of lemmas. The rest of the process is however automatic. We describe it in more detail in \S \ref{} 

The second contribution of this paper is a new automated tactic for \emph{recursion induction}. Previously, Hipster only supported structural induction over the datatypes, but has now been extended with a new tactic that uses recursion induction, following the termination order of function definitions instead of the datatype. This has proved useful for many proofs that previously failed, and can also provide shorter proofs in some cases. The new recursion induction tactic is described in  \S \ref{}.

  