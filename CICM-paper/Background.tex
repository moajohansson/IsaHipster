\section{Background}
\label{sec:background}

In this section we give a brief overview of the HipSpec system which
we use as a backend for generating conjectures. HipSpec is a
state-of-the-art inductive theorem prover and theory exploration
system for Haskell. In \cite{hipspecCADE} we showed that HipSpec is
able to automatically discover and prove the kind of equational lemmas present in
Isabelle's libraries, when given the corresponding functions written in Haskell.

HipSpec works in two stages:
\begin{enumerate}
\item Generate a set of conjectures about the functions at hand. These
  conjectures are equations between terms involving the given
  functions, and have not yet been proved correct but are nevertheless
  extensively tested.

\item Attempt to prove each of the conjectures, using already proven conjectures as assumptions. HipSpec implements this by enumerating induction schemas, and firing off many proof obligations to automated first-order logic theorem provers.
\end{enumerate}
The proving power of HipSpec comes from its capability to
automatically discover and prove lemmas, which are then used to help
subsequent proofs.

In Hipster we can not directly use HipSpec's
proof capabilities (stage (2) above); we use Isabelle for the proofs instead. Isabelle
is based on a small core of trusted axioms, and proofs must be built
on top of those axioms. In other words, we would have to reconstruct
inside Isabelle any proof that HipSpec found, so it is easier
to use Isabelle for the proofs in the first place. We do, however,
replicate HipSpec's proof search inside Isabelle.

The part of HipSpec we directly use
is its conjecture synthesis system (stage (1) above), called QuickSpec \cite{quickspec}),
which efficiently generates equations about a given set of functions and
datatypes.

QuickSpec takes a set of functions as input, and proceeds to generate all
type-correct terms up to a given limit (usually up to depth three).
The terms may contain variables (usually at most three per type).
QuickSpec attempts to divide the terms into equivalence classes such
that two terms end up in the same equivalence class if and only if
they are equal. It first assumes that all terms of the same type are
equivalent, and initially puts them in the same equivalence class.
It then picks random values for the variables in the terms
(using QuickCheck \cite{quickcheck}) and evaluates the terms.
If two terms in the same equivalence class evaluate to different
values, they cannot be equal; QuickSpec thus breaks each equivalence
class into new, smaller equivalence classes depending on what values
their terms evaluated to. This process is repeated until the
equivalence classes stabilise. We then read off equations from each
equivalence class, by picking one term of that class as a
representative and equating all the other terms to that representative.
The conjectures generated are, although not yet proved, likely to be true.

As an example, suppose we tell QuickSpec to explore the theory with list append,
\verb~@~, the empty list, \verb~[]~, and three list variables \verb~xs~,
\verb~ys~, \verb~zs~. Among the terms it will generate are
\verb~(xs@ys)@zs~, \verb~xs@(ys@zs)~, \verb~xs@[]~ and \verb~xs~.
Initially, all four will be assumed to be in the same equivalence class.
Before soon, QuickSpec will generate a variable assignment where
\verb~ys~ and \verb~zs~ are non-empty lists. Evaluating the terms with
such an assignment will split this equivalence class
into two: one containing \verb~(xs@ys)@zs~ and \verb~xs@(ys@zs)~,
and the other containing \verb~xs@[]~ and \verb~xs~.
After this, whatever variable assignments QuickSpec generates, the
terms in each class will evaluate to the same value.
Eventually, QuickSpec stops and the equations for associativity and
right identity can be read off.

