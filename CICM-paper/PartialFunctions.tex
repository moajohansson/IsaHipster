Isabelle is a logic of total functions. Nonetheless, we can define
apparently partial functions, such as \verb|hd|:
\begin{verbatim}
fun hd :: "'a list => 'a" where
  "hd (x#xs) = x"
\end{verbatim}

How do we reconcile \verb|hd| being partial with Isabelle functions
being total? The answer is that in Isabelle, \verb|hd| is total, but
the behaviour of \verb|hd []| is unspecified: it returns some
arbitrary value of type \verb|'a|. Meanwhile in Haskell, \verb|head|
is partial, but the behaviour of \verb|head []| is specified: it
crashes.

Isabelle and Haskell give different semantics to partial functions. We
must respect this difference when translating Isabelle to Haskell,
otherwise HipSpec might find equations which are not true in Isabelle
or miss equations which are not true in Haskell.\footnote{As all our
lemmas are proved in Isabelle, at least we do not risk unsoundness.}
For example, EXAMPLE.

Hipster makes sure to translate an Isabelle function into a
semantically equivalent Haskell function. We do this by adding
\emph{default arguments} that specify the return value when no case matches.
For example, we will translate \verb|hd| into:
\begin{verbatim}
head :: a -> [a] -> a
head _ (x:xs) = x
head def [] = def
\end{verbatim}
To model the notion that the default arguments are unspecified,
whenever we evaluate a test case we will pick a \emph{random} value
for each default argument. This value will vary from test case to test
case but will be consistent within one run of a test case.

A more complex example will illustrate some of the subtleties of
default arguments. Suppose we define \verb|second| as
\begin{verbatim}
second (x#y#xs) = y
\end{verbatim}
\verb|second| returns the second element of a list. It might seem that
we should translate it, by analogy with \verb|hd|, as
\begin{verbatim}
second :: a -> [a] -> a
second def (x:y:xs) = y
second def _ = def
\end{verbatim}
but this translation is \emph{wrong}! If we call \verb|second| on
several lists of length 1, it will return the same value---the default
argument---in all cases. But the Isabelle function has no such property.
\verb|second| should return an unspecified value whenever its argument
has length 1, but might return a different value for different arguments.
Because of that, the default argument must be a random \emph{function}
of the same type as the original function, that we call whenever the
original function is undefined. Thus we really have:\footnote{We lied
about the type of \texttt{hd} above.}
\begin{verbatim}
second :: ([a] -> a) -> [a] -> a
second def (x:y:xs) = y
second def xs = def xs
\end{verbatim}

...

\begin{verbatim}
fun nth :: "nat => 'a list => 'a list" where
  "nth 0 xs = hd xs"
| "nth (Suc n) xs = nth n (tl xs)"
\end{verbatim}

\verb|nth| has no missing cases, so we might want to translate it as
\begin{verbatim}
nth :: Int -> [a] -> [a]
nth 0 xs = hd ??? xs
nth (n+1) xs = nth n (tl ??? xs)
\end{verbatim}
but what should we write for \verb|???|? We need default arguments to
pass to \verb|hd| and \verb|tl|, so \verb|nth| had better receive
them as arguments. Since our functions may be mutually recursive in
arbitrarily complex ways, the easiest way is to define a record
containing default implementations of \emph{all} the functions in our
program, and pass this record to every function, regardless of whether
it has missing cases or not. Thus our \emph|nth| example will become:\footnote{For
technical reasons, the default implementations in reality are not fully
polymorphic but have typeclass constraints related to random generation.}
\begin{verbatim}
data Default = Default {
  default_hd :: forall a. [a] -> a,
  default_tl :: forall a. [a] -> [a]
  }

hd :: Default -> [a] -> a
hd _ (x:xs) = x
hd def xs = default_hd def xs

tl :: Default -> [a] -> [a]
tl _ (x:xs) = xs
tl def xs = default_tl def xs

nth :: Default -> Int -> [a] -> [a]
nth def 0 xs = hd def xs
nth (n+1) xs = nth def (tl def xs)
\end{verbatim}
Here, \verb|hd| and \verb|tl| extract their default implementations
from the record, while \verb|nth| simply passes the record to \verb|hd|
and \verb|tl| and into the recursive call. The regularity of this
transformation makes it easy to implement.

We do not use any special tricks to import the transformed program into QuickSpec,
we simply give them the transformed functions as they are (including the default argument)
and give it one variable \verb|def| of type \verb|Default|. The generated equations
will mention \verb|def|: for example, with a richer signature also containing
\verb|length| and \verb|append| we would get
\verb|nth def (length def xs) (append def xs ys) = hd def ys|.
All we have to do to get an equation suitable for Isabelle is to erase
every occurrence of \verb|def|, to get
\verb|nth (length xs) (append xs ys) = hd ys|.
Since the signature only allows one term of type \verb|Default|, namely
\verb|def|, this erasure is always possible: the principle behind it is that,
if the Haskell equation holds regardless of which default values we choose,
the Isabelle equation, in which the default values are unspecified, must also hold.
